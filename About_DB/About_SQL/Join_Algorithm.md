## Join Algorithm

SQL의 JOIN 알고리즘은 대표적으로 3개 (Nested Loop, Hash, Merge Sort)

SQL 상에서 테이블 간 조인을 하면 DB 옵티마이저가 JOIN 알고리즘을 선정해 실행함. (Nested Loop가 가장 빈번하게 사용)

### Nested Loop Join

이중 반복문처럼 생각하면 됨.

`for i in range():`
`for j in range():`
라고 하면,

작은 테이블(outer table)의 레코드(기준이 되는 컬럼)을 순회하며(i), 다른 테이블(inner)의 해당 컬럼과 조인되도록 순회(j).

즉, 최악의 경우 i * j 만큼의 순회가 이루어져야 함. O(n*m)

(+ 언제 가장 강력한가?
Indexed NL 조인은 처리할 범위가 매우 적을 때 압도적인 성능을 보임. OLTP에서 몇 개의 행만 SELECT하는 쿼리는 대부분 이 방식으로 처리됨.)

자연스럽게 테이블의 크기가 큰 경우 효율이 떨어지게 됨.

-> inner table의 해당 컬럼에 인덱스를 생성함으로써 접근 비용을 줄임 (j 과정에서 인덱스를 사용)

### Hash Join

비교적 작은 테이블의 타겟 컬럼을 해시 테이블로 만들어 큰 테이블과 조인함.

두 단계로 나누어 설명

1. Build. 작은 테이블을 순회하며 타겟 컬럼의 값을 해시화시켜 해시 테이블에 저장함.
2. Probe. 큰 테이블을 순회하며 타겟 컬럼의 값을 해시 테이블과 대응시켜 조인함.

즉, 각 테이블을 각자 순회하기에 앞선 NLJ보다 효율적임. O(n+m)

하지만 한계가 있음

1. Equal Join에서만 사용이 가능함. (<,>와 같은 비교에선 불가)
2. 인덱스가 없는 경우에 사용.
3. **해시 테이블을 따로 저장할 공간 필요함.**

#### why?

1. Equal Join에서만 사용이 가능함. (<,>와 같은 비교에선 불가)

-> 해시값을 사용해 두 테이블을 조인함. 따라서 컬럼값에 따른 해시값이 일대일 대응이 되어야 함.
반면 대소비교는 하나의 값으로 떨어지지 않고, 범위를 가지게 되기 때문에 해시를 통해 조인할 수 없음..
(+ 해시값은 해당 점에 대한 정보만 가지고 있지 무엇보다 크다, 작다, 앞선다 등의 범위에 대한 정보를 가지고 있지 않음.)

2. 인덱스가 없는 경우에 사용.

-> 인덱스가 있다면 NLJ가 성능적으로 큰 문제가 없기에 요인이 없음..?
(+ 대체로 Indexed NLJ가 성능적으로 우세함. 하지만 처리할 데이터가 매우 많을 때의 경우엔 상황에 따라 hash join이 채택될 수도 있음.)

(+ Indexed NLJ는 Random I/O인데 반해, HJ는 Sequential I/O임. 대용량 데이터 처리 시, HJ가 더 효율적일 수 있는 이유 중 하나가 됨.)

### Merge Sort Join

이는 **두 테이블이 정렬되어 있다는 가정 하**에 한 테이블의 컬럼값에 대해 나머지 테이블의 컬럼값을 대조시켜 조인함.

ex.
정렬된 두 트럼프 카드 셋이 있음. (A,B)

A에서 한 장을 뽑고 B에서 한 장을 뽑았을 때, (a,b)

1. a < b이면, B에는 a와 맞는 카드가 없음. (a를 버림)

2. a = b이면, 조인. 다음으로 넘어감.

3. a > b이면, 더 후순위의 b와 조인될 수 있음. (b를 더 뽑음.)

가장 큰 문제는 **두 테이블이 정렬**되어 있어야 한다는 것. (정렬에는 큰 비용이 따름.)

-> 정렬 비용이 적거나 없는 경우 최고의 효율을 발휘함. (클러스터형 인덱스가 조인키일 때, 이미 정렬이 된 테이블의 경우)
